---
layout: post
title: "C++Primer第五版笔记"
date: 2017-10-10 21:38:06 
tag: 其他
---

```c++
1.C++中如何区别=调用的是拷贝构造函数还是拷贝赋值运算符？(P-433)
	1、 定义 同时 初始化（定义指占用内存行为）
	2、 复制一个对象，将他作为实参传递给一个函数（按值传参）
	3、 从函数返回时赋值一个对象
	4、 初始化顺序容器的元素
	5、 根据元素初始化列表初始化数据元素。
	其他情况下，出现等号，均执行赋值操作符。

2.当一个对象的引用或者指针离开作用域时候，析构函数不会执行，只会消除引用或指针本身。

3.拷贝控制里的交换操作，不要直接调用std::swap，而是用类的swap;(P-459)

4.左值持久，右值短暂。变量是左值，字面常量或者临时创建对象是右值。(P-471)

5.只有当类没有任何版本自定义拷贝控制成员，且每个成员都有移动构造或者移动赋值，才会有合成移动构造函数。(P-475)

6.有类成员定义了拷贝构造函数且未定义移动构造函数，则移动构造函数是删除的，同理，类定义了移动构造函数，则必须定义拷贝构造函数，否则被默认删除的。(P-477)

7.引用限定符&，表示函数是一个左值，引用限定符&&，表示函数是一个右值，const和&可以同时使用，表示为const &,不用写成& const.(P-483)(限定符加在函数参数上)

8.函数声明后面的const用法:const的函数不能对其数据成员进行修改操作。const的对象，不能引用非const的成员函数。

9.当限定符重载时(参数列表相同),函数要么都加上引用限定符，要么都不加（不是函数参数加限定符）。(P-485)

10.不能被重载的运算符: ::   .*   .   ?:
一般不重载的运算符，逗号，取地址，逻辑与，逻辑或。

11.IO运算符重载，第一个参数必须是IO流引用，第二个参数必须是非常量引用，故不能将重载函数定义为类成员函数。

12.重载()，可以将函数封装成类使用。lambda就是函数对象，可以互相转换(P-507)

13.重载函数，不能直接用map.insert("+",add)，添加，add有二义性，必须显示的绑定到变量中加入。(P-512)

14.当函数重载的时候，添加到map表就有二义性，需要使用函数指针显示的指定。(P-513)

15.可以把派生类当作基类使用，也可以将基类指针或者引用绑定到派生类对象上(P-530)

16.类不能继承类本身，继承的必须是已经定义的类。

17.派生类里面存在基类的私有成员，但语法限制了不能访问。

18.访问控制和继承控制
1、公有成员，类本身的成员与对象都可以访问；保护成员和私有成员，类本身的成员可以访问，对象不可以访问。
2、公有继承
当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。即基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。
3、私有继承
当类的继承方式为私有继承时，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象，都无法访问从基类继承的私有成员。通过多次私有继承后，对于基类的成员都会成为不可访问。因此私有继承比较少用。
4、保护继承
保护继承中，基类的公有成员和私有成员都以保护成员的身份出现在派生类中，而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但是类外部通过派生类的对象无法访问它们，无论派生类的成员还是派生类的对象，都无法访问基类的私有成员。
5.友元可以访问被友元的类的公有和保护成员。友元类关系不能继承，但被友元类可以被继承，即友元类可以访问被友元的派生类中友元类部分。

19.在类申明后面加个final限定符，可以阻止被继承。(P-533)

20.(P-534)基类对象指针或引用可以绑定派生类，此时静态类型是基类，动态类型是派生类，基类对象不存在动态类型。派生类不能绑定基类，基类不能向派生类转换，即使基类引用已经绑定了一个派生类，但可以static_cast强制转换。

21.(P-536)可以用派生类初始化或者赋值给基类。

22.(P-541)含有纯虚函数的类是抽象基类，抽象基类不可以创建对象，未实现抽象基类的纯虚函数的派生类还是抽象类。

23.派生类成员名和基类相同时候，会把基类的成员隐藏。派生类函数名与基类相同是也会将基类的函数隐藏，即使参数列表不一样也会隐藏，而不是重载。可显示的加上作用域访问基类。

24.近看<<高质量C++>>时读到的关于成员函数的重载/覆盖/隐藏,把我的一点理解写出来,希望大家批评与指正.
1. 重载、覆盖与隐藏
1)．重载：成员函数具有以下的特征时发生“重载”
A．相同的范围（同一个类中）
B．函数的名字相同
C．参数类型不同（不能进行隐式类型转换）
D．Virtual关键字可有可无
2)．覆盖（也叫“继承”）：指派生类函数覆盖基类函数，特征是：
A．不同的范围（分别位于基类与派生类中）
B．函数名字相同
C．参数相同
D．基类函数必须有virtual关键字
3)．隐藏：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
A．如果派生类的函数与基类的函数同名，但是参数不同，此时不论有无virtual关键字，基类的函数都将被隐藏，注意别与重载混淆）
B．如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时基类的函数被隐藏（注意别与覆盖混淆）

25.(P-546)可以使用using改变个别成员属性

26.(P-552)基类定义了虚函数，则派生类下面的同名同参数的都是虚函数，参数不同在覆盖或报错，派生类可以忽略vritual关键字。

27.(P-555)派生类的拷贝赋值移动操作都需要显示的用派生类拷贝复制移动基类，否则基类会默认初始化，析构函数则只需要释放本派生类的资源，不需要显式的调用基类析构，它会逐层析构。

28.(P-559)容器放基类智能指针而非对象，来管理整个继承关系类。

29.(P-587)initializer_list，C++11新特性，用来实现参数化列表初始化。

30.类模版函数只有在使用到的时候才会实例化。

31.模版类型别名：template<typename T> using twin = pair<T,T>;

32.(P-601)foo(int &i),调用时候，int a[10],foo(a);是错误的，数组指针不会自动转为引用

33.(P-605) template<typename It> auto fcn(It beg,It end) -> decltype(*beg){return *beg}
```